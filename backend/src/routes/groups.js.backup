const express = require('express');
const router = express.Router();
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;
const { v4: uuidv4 } = require('uuid');
const { authenticate: authenticateToken, optionalAuthenticate: optionalAuth } = require('../middleware/auth');
const Group = require('../models/Group');
const GroupMembership = require('../models/GroupMembership');
const User = require('../models/User');
const { validateUserLocation } = require('../utils/geolocation');
const db = require('../config/database');

/**
 * Helper function to check if user has permission for a moderation action
 * Admins always have permission, moderators depend on group settings
 */
async function canModerate(group, userId, permission) {
  const membership = await GroupMembership.findByGroupAndUser(group.id, userId);

  if (!membership || membership.status !== 'active') {
    return false;
  }

  // Admins can always perform any action
  if (membership.role === 'admin') {
    return true;
  }

  // Check if user is moderator and if group allows this permission
  if (membership.role === 'moderator') {
    return group[permission] === true;
  }

  return false;
}

// Load environment variables for group uploads
const GROUP_AVATAR_PATH = process.env.GROUP_AVATAR_PATH || '../uploads/groups/avatars';
const GROUP_BANNER_PATH = process.env.GROUP_BANNER_PATH || '../uploads/groups/banners';
const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3001';

// Helper function to construct full avatar URL
const getFullAvatarUrl = (relativePath) => {
  if (!relativePath) return null;
  if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
    return relativePath;
  }
  return `${API_BASE_URL}${relativePath}`;
};

// Helper function to transform group object with full URLs
const transformGroupWithFullUrls = (group) => {
  if (!group) return null;
  return {
    ...group,
    avatar_url: getFullAvatarUrl(group.avatar_url),
    banner_url: getFullAvatarUrl(group.banner_url)
  };
};

// Multer configuration for avatar uploads
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(__dirname, GROUP_AVATAR_PATH);
    try {
      await fs.mkdir(uploadDir, { recursive: true });
      cb(null, uploadDir);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    const uniqueId = uuidv4();
    const ext = path.extname(file.originalname);
    cb(null, `group-avatar-${uniqueId}${ext}`);
  }
});

const upload = multer({
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed.'));
    }
  }
});

// Multer configuration for banner uploads
const bannerStorage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(__dirname, GROUP_BANNER_PATH);
    try {
      await fs.mkdir(uploadDir, { recursive: true });
      cb(null, uploadDir);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    const uniqueId = uuidv4();
    const ext = path.extname(file.originalname);
    cb(null, `group-banner-${uniqueId}${ext}`);
  }
});

const bannerUpload = multer({
  storage: bannerStorage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit for banners
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed.'));
    }
  }
});

/**
 * @route   GET /api/groups
 * @desc    List groups with pagination and filters
 * @access  Public
 */
router.get('/', optionalAuth, async (req, res) => {
  try {
    const {
      limit = 20,
      offset = 0,
      visibility,
      creator_id,
      search,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    const result = await Group.list({
      limit: parseInt(limit),
      offset: parseInt(offset),
      visibility,
      creator_id: creator_id ? parseInt(creator_id) : null,
      search,
      sort_by,
      sort_order
    });

    // If user is authenticated, add membership info
    let transformedGroups = result.groups.map(transformGroupWithFullUrls);

    if (req.user) {
      const db = require('../config/database');
      const membershipResult = await db.query(
        'SELECT group_id, status, role FROM group_memberships WHERE user_id = $1',
        [req.user.id]
      );
      const membershipMap = new Map();
      membershipResult.rows.forEach(m => {
        membershipMap.set(m.group_id, { status: m.status, role: m.role });
      });

      transformedGroups = transformedGroups.map(g => {
        const membership = membershipMap.get(g.id);
        if (membership) {
          g.user_membership = {
            status: membership.status,
            role: membership.role
          };
        }
        return g;
      });
    }

    // Transform groups with full URLs
    const transformedResult = {
      ...result,
      groups: transformedGroups
    };

    res.json({
      success: true,
      data: transformedResult
    });
  } catch (error) {
    console.error('Error listing groups:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to list groups'
    });
  }
});

/**
 * @route   GET /api/groups/popular
 * @desc    Get popular groups
 * @access  Public
 */
router.get('/popular', async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    const groups = await Group.getPopular(parseInt(limit));

    res.json({
      success: true,
      data: groups
    });
  } catch (error) {
    console.error('Error getting popular groups:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get popular groups'
    });
  }
});

/**
 * @route   GET /api/groups/recent
 * @desc    Get recently created groups
 * @access  Public
 */
router.get('/recent', async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    const groups = await Group.getRecent(parseInt(limit));

    res.json({
      success: true,
      data: groups
    });
  } catch (error) {
    console.error('Error getting recent groups:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get recent groups'
    });
  }
});

/**
 * @route   GET /api/groups/filtered
 * @desc    Get groups filtered by user's membership/location status
 * @access  Private
 * @query   filter: 'all' | 'joined' | 'pending' | 'available' | 'unavailable'
 */
router.get('/filtered', authenticateToken, async (req, res) => {
  try {
    const { filter = 'all', limit = 20, offset = 0 } = req.query;
    const userId = req.user.id;

    // Get user's location for geolocation checks
    const user = await User.findById(userId);
    const userLocation = {
      latitude: user.location_latitude,
      longitude: user.location_longitude,
      city: user.location_city,
      state: user.location_state,
      country: user.location_country,
      sharing: user.location_sharing
    };

    // Get all groups
    const allGroups = await Group.list({
      limit: 1000, // Get all for filtering
      offset: 0,
      sort_by: 'created_at',
      sort_order: 'DESC'
    });

    // Get user's memberships using direct query
    const db = require('../config/database');
    const membershipResult = await db.query(
      'SELECT group_id, status, role FROM group_memberships WHERE user_id = $1',
      [userId]
    );
    const membershipMap = new Map();
    membershipResult.rows.forEach(m => {
      membershipMap.set(m.group_id, { status: m.status, role: m.role });
    });

    // Filter groups based on filter type
    let filteredGroups = allGroups.groups || [];

    if (filter === 'joined') {
      // Only groups user is an active member of
      filteredGroups = filteredGroups.filter(g => {
        const membership = membershipMap.get(g.id);
        return membership?.status === 'active';
      });
    } else if (filter === 'pending') {
      // Only groups with pending membership
      filteredGroups = filteredGroups.filter(g => {
        const membership = membershipMap.get(g.id);
        return membership?.status === 'pending';
      });
    } else if (filter === 'available') {
      // Groups user can join (not joined, not pending, location allows)
      filteredGroups = filteredGroups.filter(g => {
        const membership = membershipMap.get(g.id);
        if (membership?.status === 'active' || membership?.status === 'pending') return false;

        if (g.location_restricted) {
          const locationCheck = validateUserLocation(userLocation, g);
          return locationCheck.allowed;
        }
        return true;
      });
    } else if (filter === 'unavailable') {
      // Groups user can't join due to location restrictions
      filteredGroups = filteredGroups.filter(g => {
        const membership = membershipMap.get(g.id);
        if (membership?.status === 'active' || membership?.status === 'pending') return false;

        if (g.location_restricted) {
          const locationCheck = validateUserLocation(userLocation, g);
          return !locationCheck.allowed;
        }
        return false;
      });
    }
    // 'all' shows everything

    // Apply pagination to filtered results
    const total = filteredGroups.length;
    const paginatedGroups = filteredGroups.slice(
      parseInt(offset),
      parseInt(offset) + parseInt(limit)
    );

    // Transform groups with full URLs and membership info
    const transformedGroups = paginatedGroups.map(g => {
      const transformed = transformGroupWithFullUrls(g);
      const membership = membershipMap.get(g.id);
      if (membership) {
        transformed.user_membership = {
          status: membership.status,
          role: membership.role
        };
      }
      return transformed;
    });

    res.json({
      success: true,
      data: {
        groups: transformedGroups,
        total,
        limit: parseInt(limit),
        offset: parseInt(offset)
      }
    });
  } catch (error) {
    console.error('Error filtering groups:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to filter groups'
    });
  }
});

/**
 * @route   GET /api/groups/search
 * @desc    Search groups by name or description
 * @access  Public
 */
router.get('/search', async (req, res) => {
  try {
    const { q, limit = 20, offset = 0 } = req.query;

    if (!q) {
      return res.status(400).json({
        success: false,
        error: 'Search query is required'
      });
    }

    const groups = await Group.search(q, parseInt(limit), parseInt(offset));

    // Transform groups with full URLs
    const transformedGroups = groups.map(transformGroupWithFullUrls);

    res.json({
      success: true,
      data: {
        groups: transformedGroups,
        total: transformedGroups.length,
        limit: parseInt(limit),
        offset: parseInt(offset)
      }
    });
  } catch (error) {
    console.error('Error searching groups:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to search groups'
    });
  }
});

/**
 * @route   POST /api/groups
 * @desc    Create a new group
 * @access  Private
 */
router.post('/', authenticateToken, async (req, res) => {
  try {
    const {
      name,
      display_name,
      description,
      avatar_url,
      banner_url,
      visibility = 'public',
      require_approval = false,
      post_approval_required = false,
      allow_multimedia = true,
      allowed_media_types = ['image', 'video', 'pdf', 'model', 'link'],
      max_file_size_mb = 50
    } = req.body;

    // Validation
    if (!name || !display_name) {
      return res.status(400).json({
        success: false,
        error: 'Name and display name are required'
      });
    }

    // Check if name is available
    const existingGroup = await Group.findByName(name);
    if (existingGroup) {
      return res.status(400).json({
        success: false,
        error: 'Group name already exists'
      });
    }

    // Generate slug
    const slug = await Group.generateSlug(name);

    // Create group
    const group = await Group.create({
      name,
      slug,
      display_name,
      description,
      avatar_url,
      banner_url,
      visibility,
      require_approval,
      post_approval_required,
      allow_multimedia,
      allowed_media_types,
      max_file_size_mb,
      creator_id: req.user.id
    });

    // Add creator as admin
    await GroupMembership.create({
      group_id: group.id,
      user_id: req.user.id,
      role: 'admin',
      status: 'active'
    });

    res.status(201).json({
      success: true,
      data: group
    });
  } catch (error) {
    console.error('Error creating group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create group'
    });
  }
});

/**
 * @route   GET /api/groups/:slug
 * @desc    Get group by slug
 * @access  Public
 */
router.get('/:slug', optionalAuth, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is a member (if authenticated)
    let membership = null;
    if (req.user) {
      membership = await GroupMembership.getUserRole(group.id, req.user.id);
    }

    // Check visibility
    if (group.visibility === 'private' && (!membership || membership.status !== 'active')) {
      return res.status(403).json({
        success: false,
        error: 'This group is private'
      });
    }

    // Get group with creator info
    const groupWithCreator = await Group.getWithCreator(group.id);

    // Transform URLs to full paths
    const transformedGroup = transformGroupWithFullUrls(groupWithCreator);

    res.json({
      success: true,
      data: {
        ...transformedGroup,
        user_role: membership?.role || null,
        user_status: membership?.status || null
      }
    });
  } catch (error) {
    console.error('Error getting group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get group'
    });
  }
});

/**
 * @route   PUT /api/groups/:slug
 * @desc    Update group
 * @access  Private (Admin only)
 */
router.put('/:slug', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can update group settings'
      });
    }

    const updatedGroup = await Group.update(group.id, req.body);

    res.json({
      success: true,
      data: updatedGroup
    });
  } catch (error) {
    console.error('Error updating group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update group'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/avatar
 * @desc    Upload group avatar
 * @access  Private (Admin only)
 */
router.post('/:slug/avatar', authenticateToken, upload.single('avatar'), async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can update group avatar'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded'
      });
    }

    // Resize and optimize image
    const resizedFilename = `resized-${req.file.filename}`;
    const resizedPath = path.join(path.dirname(req.file.path), resizedFilename);

    await sharp(req.file.path)
      .resize(400, 400, {
        fit: 'cover',
        position: 'center'
      })
      .jpeg({ quality: 85 })
      .toFile(resizedPath);

    // Delete original file
    await fs.unlink(req.file.path);

    // Update group avatar URL
    const avatar_url = `/uploads/groups/avatars/${resizedFilename}`;
    const updatedGroup = await Group.update(group.id, { avatar_url });

    res.json({
      success: true,
      data: {
        group: updatedGroup,
        avatar_url
      }
    });
  } catch (error) {
    console.error('Error uploading group avatar:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to upload avatar'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/banner
 * @desc    Upload group banner
 * @access  Private (Admin only)
 */
router.post('/:slug/banner', authenticateToken, bannerUpload.single('banner'), async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can update group banner'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded'
      });
    }

    // Resize and optimize banner image (wider aspect ratio)
    const resizedFilename = `resized-${req.file.filename}`;
    const resizedPath = path.join(path.dirname(req.file.path), resizedFilename);

    await sharp(req.file.path)
      .resize(1200, 400, {
        fit: 'cover',
        position: 'center'
      })
      .jpeg({ quality: 85 })
      .toFile(resizedPath);

    // Delete original file
    await fs.unlink(req.file.path);

    // Update group banner URL
    const banner_url = `/uploads/groups/banners/${resizedFilename}`;
    const updatedGroup = await Group.update(group.id, { banner_url });

    res.json({
      success: true,
      data: {
        group: updatedGroup,
        banner_url
      }
    });
  } catch (error) {
    console.error('Error uploading group banner:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to upload banner'
    });
  }
});

/**
 * @route   DELETE /api/groups/:slug
 * @desc    Delete group
 * @access  Private (Admin only)
 */
router.delete('/:slug', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can delete groups'
      });
    }

    await Group.delete(group.id);

    res.json({
      success: true,
      message: 'Group deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete group'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/members
 * @desc    Get group members
 * @access  Public (for public groups) / Members only (for private groups)
 */
router.get('/:slug/members', optionalAuth, async (req, res) => {
  try {
    const { slug } = req.params;
    const { status = 'active', role, limit = 50, offset = 0 } = req.query;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check visibility
    if (group.visibility === 'private') {
      if (!req.user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      const isMember = await GroupMembership.isMember(group.id, req.user.id);
      if (!isMember) {
        return res.status(403).json({
          success: false,
          error: 'Only members can view member list'
        });
      }
    }

    const result = await GroupMembership.getGroupMembers(group.id, {
      status,
      role,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });

    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error('Error getting group members:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get group members'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/membership
 * @desc    Check current user's membership status in a group
 * @access  Private
 */
router.get('/:slug/membership', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    const membership = await GroupMembership.findByGroupAndUser(group.id, req.user.id);

    if (!membership) {
      return res.json({
        success: true,
        data: {
          is_member: false
        }
      });
    }

    res.json({
      success: true,
      data: {
        is_member: true,
        membership: {
          role: membership.role,
          status: membership.status,
          joined_at: membership.joined_at
        }
      }
    });
  } catch (error) {
    console.error('Error checking membership:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to check membership status'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/join
 * @desc    Join a group
 * @access  Private
 */
router.post('/:slug/join', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if already a member
    const existingMembership = await GroupMembership.findByGroupAndUser(group.id, req.user.id);
    if (existingMembership) {
      return res.status(400).json({
        success: false,
        error: 'Already a member of this group'
      });
    }

    // Check location restrictions
    if (group.location_restricted) {
      const user = await User.findById(req.user.id);

      // Construct location object from individual columns
      const userLocation = {
        latitude: user.location_latitude,
        longitude: user.location_longitude,
        city: user.location_city,
        state: user.location_state,
        country: user.location_country,
        sharing: user.location_sharing
      };

      const locationCheck = validateUserLocation(userLocation, group);
      if (!locationCheck.allowed) {
        return res.status(403).json({
          success: false,
          error: locationCheck.reason
        });
      }
    }

    // Check group settings
    let status = 'active';
    if (group.visibility === 'invite_only') {
      return res.status(403).json({
        success: false,
        error: 'This group is invite-only'
      });
    }
    if (group.require_approval) {
      status = 'pending';
    }

    const membership = await GroupMembership.create({
      group_id: group.id,
      user_id: req.user.id,
      role: 'member',
      status
    });

    res.status(201).json({
      success: true,
      data: membership,
      message: status === 'pending' ? 'Membership pending approval' : 'Successfully joined group'
    });
  } catch (error) {
    console.error('Error joining group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to join group'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/leave
 * @desc    Leave a group
 * @access  Private
 */
router.post('/:slug/leave', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is the creator
    if (group.creator_id === req.user.id) {
      return res.status(400).json({
        success: false,
        error: 'Group creator cannot leave. Transfer ownership or delete the group.'
      });
    }

    // Check if user is a member
    const isMember = await GroupMembership.isMember(group.id, req.user.id);
    if (!isMember) {
      return res.status(400).json({
        success: false,
        error: 'You are not a member of this group'
      });
    }

    await GroupMembership.delete(group.id, req.user.id);

    res.json({
      success: true,
      message: 'Successfully left group'
    });
  } catch (error) {
    console.error('Error leaving group:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to leave group'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/members/:userId/role
 * @desc    Update member role
 * @access  Private (Admin only)
 */
router.post('/:slug/members/:userId/role', authenticateToken, async (req, res) => {
  try {
    const { slug, userId } = req.params;
    const { role } = req.body;

    if (!['member', 'moderator', 'admin'].includes(role)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid role'
      });
    }

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can change member roles'
      });
    }

    const updatedMembership = await GroupMembership.update(group.id, parseInt(userId), { role });

    res.json({
      success: true,
      data: updatedMembership
    });
  } catch (error) {
    console.error('Error updating member role:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update member role'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/members/:userId/ban
 * @desc    Ban a member
 * @access  Private (Moderator/Admin only)
 */
router.post('/:slug/members/:userId/ban', authenticateToken, async (req, res) => {
  try {
    const { slug, userId } = req.params;
    const { banned_reason } = req.body;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user has permission to ban members
    const hasPermission = await canModerate(group, req.user.id, 'moderator_can_ban_members');
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to ban members'
      });
    }

    const updatedMembership = await GroupMembership.ban(
      group.id,
      parseInt(userId),
      req.user.id,
      banned_reason
    );

    res.json({
      success: true,
      data: updatedMembership
    });
  } catch (error) {
    console.error('Error banning member:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to ban member'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/members/:userId/unban
 * @desc    Unban a member
 * @access  Private (Moderator/Admin only)
 */
router.post('/:slug/members/:userId/unban', authenticateToken, async (req, res) => {
  try {
    const { slug, userId } = req.params;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user has permission to ban/unban members
    const hasPermission = await canModerate(group, req.user.id, 'moderator_can_ban_members');
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to unban members'
      });
    }

    const updatedMembership = await GroupMembership.unban(group.id, parseInt(userId));

    res.json({
      success: true,
      data: updatedMembership
    });
  } catch (error) {
    console.error('Error unbanning member:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to unban member'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/members/pending
 * @desc    Get pending membership requests
 * @access  Private (Moderators/Admins only)
 */
router.get('/:slug/members/pending', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const { limit = 20, offset = 0 } = req.query;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is moderator or admin
    const isModerator = await GroupMembership.isModerator(group.id, req.user.id);
    if (!isModerator) {
      return res.status(403).json({
        success: false,
        error: 'Only moderators and admins can view pending membership requests'
      });
    }

    const members = await GroupMembership.getPendingRequests(group.id);

    res.json({
      success: true,
      data: { members }
    });
  } catch (error) {
    console.error('Error getting pending members:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get pending members'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/members/:userId/approve
 * @desc    Approve a pending membership request
 * @access  Private (Moderators/Admins only)
 */
router.post('/:slug/members/:userId/approve', authenticateToken, async (req, res) => {
  try {
    const { slug, userId } = req.params;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user has permission to approve members
    const hasPermission = await canModerate(group, req.user.id, 'moderator_can_approve_members');
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to approve membership requests'
      });
    }

    const membership = await GroupMembership.approve(group.id, parseInt(userId));

    res.json({
      success: true,
      data: membership,
      message: 'Membership approved successfully'
    });
  } catch (error) {
    console.error('Error approving membership:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to approve membership'
    });
  }
});

/**
 * @route   POST /api/groups/:slug/members/:userId/reject
 * @desc    Reject a pending membership request
 * @access  Private (Moderators/Admins only)
 */
router.post('/:slug/members/:userId/reject', authenticateToken, async (req, res) => {
  try {
    const { slug, userId } = req.params;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is moderator or admin
    const isModerator = await GroupMembership.isModerator(group.id, req.user.id);
    if (!isModerator) {
      return res.status(403).json({
        success: false,
        error: 'Only moderators and admins can reject membership requests'
      });
    }

    await GroupMembership.reject(group.id, parseInt(userId));

    res.json({
      success: true,
      message: 'Membership rejected successfully'
    });
  } catch (error) {
    console.error('Error rejecting membership:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to reject membership'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/activity
 * @desc    Get group activity log
 * @access  Private (Moderators/Admins only)
 */
router.get('/:slug/activity', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const { limit = 50, offset = 0 } = req.query;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is moderator or admin
    const isModerator = await GroupMembership.isModerator(group.id, req.user.id);
    if (!isModerator) {
      return res.status(403).json({
        success: false,
        error: 'Only moderators and admins can view activity log'
      });
    }

    // Query activity log
    const queryText = `
      SELECT
        ga.*,
        u.username as moderator_username,
        u.first_name,
        u.last_name,
        t.username as target_username
      FROM group_activity_log ga
      LEFT JOIN users u ON ga.user_id = u.id
      LEFT JOIN users t ON ga.target_id = t.id AND ga.target_type = 'user'
      WHERE ga.group_id = $1
      ORDER BY ga.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    const result = await db.query(queryText, [group.id, parseInt(limit), parseInt(offset)]);

    res.json({
      success: true,
      data: {
        activities: result.rows,
        total: result.rowCount
      }
    });
  } catch (error) {
    console.error('Error getting activity log:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get activity log'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/members/banned
 * @desc    Get banned members list
 * @access  Private (Moderators/Admins only)
 */
router.get('/:slug/members/banned', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const { limit = 20, offset = 0 } = req.query;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is moderator or admin
    const isModerator = await GroupMembership.isModerator(group.id, req.user.id);
    if (!isModerator) {
      return res.status(403).json({
        success: false,
        error: 'Only moderators and admins can view banned members'
      });
    }

    const members = await GroupMembership.getBannedUsers(group.id);

    res.json({
      success: true,
      data: { members }
    });
  } catch (error) {
    console.error('Error getting banned members:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get banned members'
    });
  }
});

/**
 * @route   GET /api/groups/:slug/chat
 * @desc    Get group chat conversation
 * @access  Private (Members only)
 */
router.get('/:slug/chat', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const group = await Group.findBySlug(slug);

    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is an active member
    const membership = await GroupMembership.findByGroupAndUser(group.id, req.user.id);
    if (!membership || membership.status !== 'active') {
      return res.status(403).json({
        success: false,
        error: 'You must be a member to access group chat'
      });
    }

    // Check if chat is enabled
    const chatEnabled = group.settings && group.settings.chat_enabled === true;
    if (!chatEnabled || !group.conversation_id) {
      return res.status(404).json({
        success: false,
        error: 'Group chat is not enabled'
      });
    }

    // Get conversation details
    const result = await db.query(`
      SELECT c.*,
        json_agg(
          json_build_object(
            'id', u.id,
            'username', u.username,
            'avatar_url', u.avatar_url
          )
        ) FILTER (WHERE cp.left_at IS NULL) as participants
      FROM conversations c
      LEFT JOIN conversation_participants cp ON c.id = cp.conversation_id
      LEFT JOIN users u ON cp.user_id = u.id
      WHERE c.id = $1
      GROUP BY c.id
    `, [group.conversation_id]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Conversation not found'
      });
    }

    const conversation = result.rows[0];

    res.json({
      success: true,
      data: { conversation }
    });
  } catch (error) {
    console.error('Error getting group chat:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get group chat'
    });
  }
});

/**
 * @route   PUT /api/groups/:slug/chat/toggle
 * @desc    Enable or disable group chat
 * @access  Private (Admin only)
 */
router.put('/:slug/chat/toggle', authenticateToken, async (req, res) => {
  try {
    const { slug } = req.params;
    const { enabled } = req.body;

    const group = await Group.findBySlug(slug);
    if (!group) {
      return res.status(404).json({
        success: false,
        error: 'Group not found'
      });
    }

    // Check if user is admin
    const isAdmin = await GroupMembership.isAdmin(group.id, req.user.id);
    if (!isAdmin) {
      return res.status(403).json({
        success: false,
        error: 'Only admins can modify chat settings'
      });
    }

    // Handle enabling chat
    if (enabled && !group.conversation_id) {
      // Create a new group conversation
      const conversationResult = await db.query(`
        INSERT INTO conversations (type, title, created_by, group_id, created_at, updated_at)
        VALUES ('group', $1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        RETURNING *
      `, [`${group.display_name} Chat`, req.user.id, group.id]);

      const conversation = conversationResult.rows[0];

      // Update group with conversation_id
      await db.query(`
        UPDATE groups
        SET conversation_id = $1,
            settings = jsonb_set(COALESCE(settings, '{}'::jsonb), '{chat_enabled}', 'true'::jsonb),
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $2
      `, [conversation.id, group.id]);

      // Add all active members to the conversation
      const members = await db.query(`
        SELECT user_id
        FROM group_memberships
        WHERE group_id = $1 AND status = 'active'
      `, [group.id]);

      for (const member of members.rows) {
        await db.query(`
          INSERT INTO conversation_participants (conversation_id, user_id, role, joined_at)
          VALUES ($1, $2, 'member', CURRENT_TIMESTAMP)
          ON CONFLICT (conversation_id, user_id, left_at)
          WHERE left_at IS NULL
          DO NOTHING
        `, [conversation.id, member.user_id]);
      }

      // Get updated group
      const updatedGroup = await Group.findBySlug(slug);

      res.json({
        success: true,
        data: { group: updatedGroup },
        message: 'Group chat enabled successfully'
      });
    }
    // Handle disabling chat
    else if (!enabled && group.conversation_id) {
      // Update settings to disable chat
      await db.query(`
        UPDATE groups
        SET settings = jsonb_set(COALESCE(settings, '{}'::jsonb), '{chat_enabled}', 'false'::jsonb),
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [group.id]);

      const updatedGroup = await Group.findBySlug(slug);

      res.json({
        success: true,
        data: { group: updatedGroup },
        message: 'Group chat disabled successfully'
      });
    }
    // Handle re-enabling chat
    else if (enabled && group.conversation_id) {
      await db.query(`
        UPDATE groups
        SET settings = jsonb_set(COALESCE(settings, '{}'::jsonb), '{chat_enabled}', 'true'::jsonb),
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [group.id]);

      const updatedGroup = await Group.findBySlug(slug);

      res.json({
        success: true,
        data: { group: updatedGroup },
        message: 'Group chat re-enabled successfully'
      });
    } else {
      res.json({
        success: true,
        data: { group },
        message: 'No changes made'
      });
    }
  } catch (error) {
    console.error('Error toggling group chat:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to toggle group chat'
    });
  }
});

module.exports = router;
